{"version":3,"sources":["../../../projects/ngx-cookie/src/lib/tokens.ts","../../../projects/ngx-cookie/src/lib/utils.ts","../../../projects/ngx-cookie/src/lib/cookie-options.provider.ts","../../../projects/ngx-cookie/src/lib/cookie.service.ts","../../../projects/ngx-cookie/src/lib/cookie-writer.service.ts","../../../projects/ngx-cookie/src/lib/cookie.factory.ts","../../../projects/ngx-cookie/src/lib/cookie.module.ts"],"names":["COOKIE_OPTIONS","InjectionToken","COOKIE_WRITER","isNil","obj","isPresent","isString","mergeOptions","oldOptions","newOptions","path","domain","expires","secure","sameSite","httpOnly","storeUnencoded","parseCookieString","currentCookieString","cookieArray","cookie","i","index","name","lastCookies","lastCookieString","split","length","indexOf","safeDecodeURIComponent","substring","buildCookieString","value","options","val","Date","cookieValue","encodeURIComponent","str","toUTCString","cookieLength","console","log","decodeURIComponent","e","injector","this","defaultOptions","get","APP_BASE_HREF","undefined","Injectable","Inject","args","Injector","CookieService","document","optionsProvider","cookieWriterService","prototype","hasKey","key","_a","getAll","getObject","JSON","parse","readAllAsString","put","opts","write","putObject","stringify","remove","removeAll","_this","cookies","Object","keys","forEach","DOCUMENT","CookieOptionsProvider","CookieWriterService","cookieServiceFactory","cookieOptionsProvider","CookieModule","forRoot","ngModule","providers","provide","useValue","useClass","useFactory","deps","forChild","NgModule","Array","isArray","constructor"],"mappings":"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","sourcesContent":["import { InjectionToken } from '@angular/core';\n\nimport { CookieOptions, ICookieWriterService } from './cookie.model';\n\nexport const COOKIE_OPTIONS = new InjectionToken<CookieOptions>('COOKIE_OPTIONS');\nexport const COOKIE_WRITER = new InjectionToken<ICookieWriterService>('COOKIE_WRITER');\n","import { CookieDict, CookieOptions } from './cookie.model';\n\n// tslint:disable-next-line:no-any\nexport function isNil(obj: any): boolean {\n  return obj === undefined || obj === null;\n}\n\n// tslint:disable-next-line:no-any\nexport function isPresent(obj: any): boolean {\n  return !isNil(obj);\n}\n\n// tslint:disable-next-line:no-any\nexport function isString(obj: any): obj is string {\n  return typeof obj === 'string';\n}\n\n// noinspection JSUnusedGlobalSymbols\n// tslint:disable-next-line:no-any\nexport function isEmpty(value: any): boolean {\n  if (isNil(value)) {\n    return true;\n  }\n  if (value === {}) {\n    return true;\n  }\n  if (Array.isArray(value) && value.length === 0) {\n    return true;\n  }\n  if (typeof value !== 'boolean' && !value) {\n    return true;\n  }\n  // noinspection RedundantIfStatementJS\n  if (Object.keys(value).length === 0 && value.constructor === Object) {\n    return true;\n  }\n  return false;\n}\n\nexport function mergeOptions(oldOptions: CookieOptions, newOptions?: CookieOptions): CookieOptions {\n  if (!newOptions) {\n    return oldOptions;\n  }\n  return {\n    path: isPresent(newOptions.path) ? newOptions.path : oldOptions.path,\n    domain: isPresent(newOptions.domain) ? newOptions.domain : oldOptions.domain,\n    expires: isPresent(newOptions.expires) ? newOptions.expires : oldOptions.expires,\n    secure: isPresent(newOptions.secure) ? newOptions.secure : oldOptions.secure,\n    sameSite: isPresent(newOptions.sameSite) ? newOptions.sameSite : oldOptions.sameSite,\n    httpOnly: isPresent(newOptions.httpOnly) ? newOptions.httpOnly : oldOptions.httpOnly,\n    storeUnencoded: isPresent(newOptions.storeUnencoded) ? newOptions.storeUnencoded : oldOptions.storeUnencoded\n  };\n}\n\nexport function parseCookieString(currentCookieString: string): CookieDict {\n  let lastCookies: CookieDict = {};\n  let lastCookieString = '';\n  let cookieArray: string[];\n  let cookie: string;\n  let i: number;\n  let index: number;\n  let name: string;\n  if (currentCookieString !== lastCookieString) {\n    lastCookieString = currentCookieString;\n    cookieArray = lastCookieString.split('; ');\n    lastCookies = {};\n    for (i = 0; i < cookieArray.length; i++) {\n      cookie = cookieArray[i];\n      index = cookie.indexOf('=');\n      if (index > 0) {  // ignore nameless cookies\n        name = safeDecodeURIComponent(cookie.substring(0, index));\n        // the first value that is seen for a cookie is the most\n        // specific one.  values for the same cookie name that\n        // follow are for less specific paths.\n        if (isNil((lastCookies)[name])) {\n          lastCookies[name] = safeDecodeURIComponent(cookie.substring(index + 1));\n        }\n      }\n    }\n  }\n  return lastCookies;\n}\n\nexport function buildCookieString(name: string, value: string | undefined, options?: CookieOptions): string {\n  let expires: string | Date | undefined = options?.expires;\n  let val: string;\n  if (isNil(value)) {\n    expires = 'Thu, 01 Jan 1970 00:00:00 GMT';\n    val = '';\n  } else {\n    val = value as string;\n  }\n  if (isString(expires)) {\n    expires = new Date(expires);\n  }\n  const cookieValue = options?.storeUnencoded ? value : encodeURIComponent(val);\n  let str = encodeURIComponent(name) + '=' + cookieValue;\n  str += options?.path ? ';path=' + options.path : '';\n  str += options?.domain ? ';domain=' + options.domain : '';\n  str += expires ? ';expires=' + expires.toUTCString() : '';\n  str += options?.sameSite ? '; SameSite=' + options.sameSite : '';\n  str += options?.secure ? ';secure' : '';\n  str += options?.httpOnly ? '; HttpOnly' : '';\n\n  // per http://www.ietf.org/rfc/rfc2109.txt browser must allow at minimum:\n  // - 300 cookies\n  // - 20 cookies per unique domain\n  // - 4096 bytes per cookie\n  const cookieLength = str.length + 1;\n  if (cookieLength > 4096) {\n    console.log('Cookie \\'' + name + '\\' possibly not set or overflowed because it was too large (' + cookieLength + ' > 4096 bytes)!');\n  }\n  return str;\n}\n\nexport function safeDecodeURIComponent(str: string): string {\n  try {\n    return decodeURIComponent(str);\n  } catch (e) {\n    return str;\n  }\n}\n","import { APP_BASE_HREF } from '@angular/common';\nimport { Inject, Injectable, Injector } from '@angular/core';\n\nimport { CookieOptions } from './cookie.model';\nimport { COOKIE_OPTIONS } from './tokens';\nimport { mergeOptions } from './utils';\n\n@Injectable()\nexport class CookieOptionsProvider {\n\n  readonly options: CookieOptions;\n  private readonly defaultOptions: CookieOptions;\n\n  constructor(@Inject(COOKIE_OPTIONS) options: CookieOptions = {},\n              private injector: Injector) {\n    this.defaultOptions = {\n      path: this.injector.get(APP_BASE_HREF, '/'),\n      domain: undefined,\n      expires: undefined,\n      secure: false,\n      httpOnly: false\n    };\n    this.options = mergeOptions(this.defaultOptions, options);\n  }\n\n}\n","import { DOCUMENT } from '@angular/common';\nimport { Inject, Injectable } from '@angular/core';\nimport { CookieOptionsProvider } from './cookie-options.provider';\n\nimport { CookieDict, CookieOptions, ICookieService, ICookieWriterService } from './cookie.model';\nimport { COOKIE_WRITER } from './tokens';\nimport { isNil, isPresent, mergeOptions, parseCookieString } from './utils';\n\n@Injectable()\nexport class CookieService implements ICookieService {\n\n  protected options: CookieOptions;\n\n  constructor(@Inject(DOCUMENT) private document: any,\n              private optionsProvider: CookieOptionsProvider,\n              @Inject(COOKIE_WRITER) private cookieWriterService: ICookieWriterService) {\n    this.options = this.optionsProvider.options;\n  }\n\n  /**\n   * @description\n   * Returns if the given cookie key exists or not.\n   *\n   * @param key Id to use for lookup.\n   * @returns true if key exists, otherwise false.\n   */\n  hasKey(key: string): boolean {\n    const value = this.get(key);\n    return isPresent(value);\n  }\n\n  /**\n   * @description\n   * Returns the value of given cookie key.\n   *\n   * @param key Id to use for lookup.\n   * @returns Raw cookie value.\n   */\n  get(key: string): string {\n    return this.getAll()?.[key];\n  }\n\n  /**\n   * @description\n   * Returns the deserialized value of given cookie key.\n   *\n   * @param key Id to use for lookup.\n   * @returns Deserialized cookie value.\n   */\n  getObject(key: string): object | undefined {\n    const value = this.get(key);\n    if (isNil(value)) {\n      return undefined;\n    } else if (value === '') {\n      return {};\n    }\n    return JSON.parse(value);\n  }\n\n  /**\n   * @description\n   * Returns a key value object with all the cookies.\n   *\n   * @returns All cookies\n   */\n  getAll(): CookieDict {\n    const cookieString = this.cookieWriterService.readAllAsString();\n    return parseCookieString(cookieString);\n  }\n\n  /**\n   * @description\n   * Sets a value for given cookie key.\n   *\n   * @param key Id for the `value`.\n   * @param value Raw value to be stored.\n   * @param options (Optional) Options object.\n   */\n  put(key: string, value: string | undefined, options?: CookieOptions): void {\n    const opts = mergeOptions(this.options, options);\n    this.cookieWriterService.write(key, value, opts);\n  }\n\n  /**\n   * @description\n   * Serializes and sets a value for given cookie key.\n   *\n   * @param key Id for the `value`.\n   * @param value Value to be stored.\n   * @param options (Optional) Options object.\n   */\n  putObject(key: string, value: object, options?: CookieOptions): void {\n    this.put(key, JSON.stringify(value), options);\n  }\n\n  /**\n   * @description\n   * Remove given cookie.\n   *\n   * @param key Id of the key-value pair to delete.\n   * @param options (Optional) Options object.\n   */\n  remove(key: string, options?: CookieOptions): void {\n    this.put(key, undefined, options);\n  }\n\n  /**\n   * @description\n   * Remove all cookies.\n   */\n  removeAll(options?: CookieOptions): void {\n    const cookies = this.getAll();\n    Object.keys(cookies).forEach(key => this.remove(key, options));\n  }\n\n}\n","import { DOCUMENT } from '@angular/common';\nimport { Inject, Injectable } from '@angular/core';\n\nimport { CookieOptions, ICookieWriterService } from './cookie.model';\nimport { buildCookieString } from './utils';\n\n@Injectable()\nexport class CookieWriterService implements ICookieWriterService {\n\n  constructor(@Inject(DOCUMENT) private document: any) {}\n\n  readAllAsString(): string {\n    return this.document.cookie || '';\n  }\n\n  write(name: string, value: string | undefined, options?: CookieOptions): void {\n    this.document.cookie = buildCookieString(name, value, options);\n  }\n\n}\n","import { CookieOptionsProvider } from './cookie-options.provider';\nimport { ICookieWriterService } from './cookie.model';\nimport { CookieService } from './cookie.service';\n\nexport function cookieServiceFactory(document: Document,\n                                     cookieOptionsProvider: CookieOptionsProvider,\n                                     cookieWriterService: ICookieWriterService): CookieService {\n  return new CookieService(document, cookieOptionsProvider, cookieWriterService);\n}\n","import { DOCUMENT } from '@angular/common';\nimport { ModuleWithProviders, NgModule } from '@angular/core';\nimport { CookieWriterService } from './cookie-writer.service';\n\nimport { CookieOptions } from './cookie.model';\nimport { CookieOptionsProvider } from './cookie-options.provider';\nimport { cookieServiceFactory } from './cookie.factory';\nimport { CookieService } from './cookie.service';\nimport { COOKIE_OPTIONS, COOKIE_WRITER } from './tokens';\n\n\n@NgModule({\n  providers: [CookieOptionsProvider]\n})\nexport class CookieModule {\n  /**\n   * Use this method in your root module to provide the CookieService\n   */\n  static forRoot(options: CookieOptions = {}): ModuleWithProviders<CookieModule> {\n    return {\n      ngModule: CookieModule,\n      providers: [\n        {provide: COOKIE_OPTIONS, useValue: options},\n        {provide: COOKIE_WRITER, useClass: CookieWriterService},\n        {provide: CookieService, useFactory: cookieServiceFactory, deps: [DOCUMENT, CookieOptionsProvider, COOKIE_WRITER]}\n      ]\n    };\n  }\n\n  /**\n   * Use this method in your other (non root) modules to import the directive/pipe\n   */\n  static forChild(options: CookieOptions = {}): ModuleWithProviders<CookieModule> {\n    return CookieModule.forRoot(options);\n  }\n}\n"]}